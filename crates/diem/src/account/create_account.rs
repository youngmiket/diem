// Copyright (c) The Diem Core Contributors
// SPDX-License-Identifier: Apache-2.0



use crate::common::types:: {
    CliCommand,CliError, CliTypedResult
};

use crate::{
    client_proxy::ClientProxy,
};
use structopt::StructOpt;


use async_trait::async_trait;
use clap::{Parser};
use serde_json::json;
use std::{
    fmt::{Display, Formatter},
    str::FromStr,
};
use diem_types::{chain_id::ChainId, waypoint::Waypoint};

#[derive(Debug, StructOpt)]
#[structopt(
    name = "Diem Client",
    author = "The Diem Association",
    about = "Diem client to connect to a specific validator"
)]
struct DefaultArgs {
    /// Chain ID of the network this client is connecting to
    #[structopt(
        short = "c",
        long,
        help = "\
            Explicitly specify the chain ID of the network the CLI is connecting to: e.g.,
            for mainnet: \"MAINNET\" or 1, testnet: \"TESTNET\" or 2, devnet: \"DEVNET\" or 3, \
            local swarm: \"TESTING\" or 4
            Note: Chain ID of 0 is not allowed
        "
    )]
    pub chain_id: ChainId,
    /// Full URL address to connect to - should include port number, if applicable
    #[structopt(short = "u", long)]
    pub url: String,
    /// Path to the generated keypair for the faucet account. The faucet account can be used to
    /// mint coins. If not passed, a new keypair will be generated for
    /// you and placed in a temporary directory.
    /// To manually generate a keypair, use generate-key:
    /// `cargo run -p generate-keypair -- -o <output_file_path>`
    #[structopt(short = "m", long = "faucet-key-file-path")]
    pub faucet_account_file: Option<String>,
    /// Host that operates a faucet service
    /// If not passed, will be derived from host parameter
    #[structopt(short = "f", long)]
    pub faucet_url: Option<String>,
    /// File location from which to load mnemonic word for user account address/key generation.
    /// If not passed, a new mnemonic file will be generated by diem-wallet in the current
    /// directory.
    #[structopt(short = "n", long)]
    pub mnemonic_file: Option<String>,
    /// If set, client will sync with validator during wallet recovery.
    #[structopt(short = "r", long = "sync")]
    pub sync: bool,
    /// If set, a client uses the waypoint parameter for its initial LedgerInfo verification.
    #[structopt(
        name = "waypoint",
        long,
        help = "Explicitly specify the waypoint to use",
        required_unless = "waypoint_url"
    )]
    pub waypoint: Option<Waypoint>,
    #[structopt(
        name = "waypoint_url",
        long,
        help = "URL for a file with the waypoint to use",
        required_unless = "waypoint"
    )]
    pub waypoint_url: Option<String>,
    /// Verbose output.
    #[structopt(short = "v", long = "verbose")]
    pub verbose: bool,
}

impl DefaultArgs {
    //temporary default arguments for development
    pub fn new() -> Self {
        let testnet = String::from("TESTNET");
        let chain_id = ChainId::from_str(&testnet).unwrap();

        DefaultArgs { chain_id: chain_id, url: String::from("https://testnet.diem.com/v1"), faucet_account_file: None, faucet_url: None, mnemonic_file: None, sync: false, waypoint: None, waypoint_url: Some(String::from("https://testnet.diem.com/waypoint.txt")), verbose: true }
    }

    
}


/// Create a new account on-chain
///
/// An account can be created by transferring coins, or by making an explicit
/// call to create an account.  This will create an account with no coins, and
/// any coins will have to transferred afterwards.
#[derive(Debug, Parser)]
pub struct CreateAccount {}

#[async_trait]
impl CliCommand<String> for CreateAccount {
    fn command_name(&self) -> &'static str {
        "CreateAccount"
    }

    async fn execute(self) -> CliTypedResult<String> {

        
        let mut client = default_proxy().await;

        match client.create_next_account(true).await {
            Ok(account_data) => println!(
                "Created/retrieved local account #{} address {}",
                account_data.index,
                hex::encode(account_data.address)
            ),
            Err(e) => println!("Error creating local account {}", e),
        }
        

        println!("Created account...");
        Ok("account".to_string())
    }
}

pub async fn default_proxy() -> ClientProxy {

    //default for testing
    let args = DefaultArgs::new();
    
    
    let faucet_account_file = args
        .faucet_account_file
        .clone()
        .unwrap_or_else(|| "".to_string());
    // Faucet, TreasuryCompliance and DD use the same keypair for now
    let treasury_compliance_account_file = faucet_account_file.clone();
    let dd_account_file = faucet_account_file.clone();
    let mnemonic_file = args.mnemonic_file.clone();

    // let waypoint = args.waypoint.unwrap_or_else(|| async {
    //     args.waypoint_url
    //         .as_ref()
    //         .map(|url_str| async{
    //             retrieve_waypoint(url_str.as_str()).await.unwrap_or_else(|e| {
    //                 panic!("Failure to retrieve a waypoint from {}: {}", url_str, e)
    //             })
    //         })
    //         .unwrap()
    // });

    //default for testing
    let waypoint = retrieve_waypoint("https://testnet.diem.com/waypoint.txt").await.unwrap();


    let mut client_proxy = ClientProxy::new(
        args.chain_id,
        &args.url,
        &faucet_account_file,
        &treasury_compliance_account_file,
        &dd_account_file,
        args.sync,
        args.faucet_url.clone(),
        mnemonic_file,
        waypoint,
        false,
    ).await
    .expect("Failed to construct client.");
    
    client_proxy
}

/// Retrieve a waypoint given the URL.
async fn retrieve_waypoint(url_str: &str) -> anyhow::Result<Waypoint> {
    let client = reqwest::ClientBuilder::new().build()?;
    let response = client.get(url_str).send().await?;

    response
        .error_for_status()
        .map_err(|_| anyhow::format_err!("Failed to retrieve waypoint from URL {}", url_str))?
        .text().await
        .map(|r| Waypoint::from_str(r.trim()))?
}